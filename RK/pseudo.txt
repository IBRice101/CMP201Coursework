Explanation:
RK Uses hashing
    Hashing takes a chunk of data and returns an int
RK Hashes the pattern (needle) and then computes the corresponding section of the text (haystack)
if needleHash == haystackHash, match

can be sped up by reusing the hash of previously calculated strings
    so is the word we were analysing was "dundee", I will have calculated "dunde"'s hash already and can easily work out
     the hash for "undee" by subtracting the hash for the letter d and adding the hash for the letter e

Pseudocode:

needle is any arbitrary bit of text
haystack is a larger bit of text that may contain needle

Input: needle, haystack

Begin
   nLen is set to needle Length
   hLen is set to haystack Length
   nHash is set to 0 and hHash is set to 0, haystack is set to 1
   maxChar is set to total number of characters in character set

   for index i of all character in pattern, do
      haystack is set to (haystack*maxChar) mod prime
   done

   for all character index i of pattern, do
      nHash is set to (maxChar*nHash + pattern[i]) mod prime
      hHash is set to (maxChar*hHash + text[i]) mod prime
   done

   for i is set to 0 to (hLen - nLen), do
      if nHash = hHash, then
         for charIndex is set to 0 to nLen -1, do
            if text[i+charIndex] ≠ pattern[charIndex], then
               break the loop
         done

         if charIndex = nLen, then
            print the location i as pattern found at i position.
      if i < (hLen - nLen), then
         hHash is set to (maxChar*(hHash – text[i]*haystack)+text[i+nLen]) mod prime, then
      if hHash < 0, then
         hHash is set to hHash + prime
   done
End